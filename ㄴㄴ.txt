✓ 파일: code_corpus.parquet

총 행 수: 3,243,424
총 Row Group 수: 3236

랜덤 선택된 Row Group: [3029, 2999, 2183, 17, 2239]

======================================================================
🎲 랜덤 샘플 10개
======================================================================

======================================================================
샘플 #1
======================================================================

[submission_id]: s639857121

[problem_id]: p03824

[text]:
------------------------------------------------------------
import sys
range = xrange

def decomp(coupl, root = 0):
    n = len(coupl)
    visible_labels = [0] * n
    
    bfs = [root]
    for node in bfs:
        for nei in coupl[node]:
            coupl[nei].remove(node)
        bfs += coupl[node]

    for node in reversed(bfs):
        seen = seen_twice = 0
        for nei in coupl[node]:
            seen_twice |= seen & visible_labels[nei]
            seen |= visible_labels[nei]
        tmp = ~seen & -(1 << seen_twice.bit_length()) 
        label = tmp & -tmp
        visible_labels[node] = (label | seen) & -label
    
    return [(seen & -seen).bit_length() - 1 for seen in visible_labels]

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

n = inp[ii]; ii += 1
coupl = [[] for _ in range(n)]
for _ in range(n - 1):
    u = inp[ii] - 1; ii += 1
    v = inp[ii] - 1; ii += 1
    coupl[u].append(v)
    coupl[v].append(u)

print max(decomp(coupl))

------------------------------------------------------------

[code_sha1]: b37535d2082a9d4dac0f1d0f58490178b9c43643

[code_bytes]: 907

[language]: Python

[status]: Accepted

[date]: 1599821275

[user_id]: u925782032

[n_chars]: 907

[n_lines]: 36

======================================================================
샘플 #2
======================================================================

[submission_id]: s027198288

[problem_id]: p03824

[text]:
------------------------------------------------------------
import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N = int(readline())
m = map(int,read().split())
AB = zip(m,m)

graph = [[] for _ in range(N+1)]
for a,b in AB:
    graph[a].append(b)
    graph[b].append(a)

graph

root = 1
parent = [0] * (N+1)
order = []
stack = [root]
while stack:
    x = stack.pop()
    order.append(x)
    for y in graph[x]:
        if y == parent[x]:
            continue
        parent[y] = x
        stack.append(y)

uninity = [0] * (N+1)
dp = [(1<<60)-1] * (N+1) # 使用可能なbitの集合
for x in order[::-1]:
    p = parent[x]
    # 使用可能なmin
    lsb = dp[x] & (-dp[x])
    uninity[x] = lsb
    dp[x] ^= lsb
    dp[x] |= (lsb - 1)
    dp[p] &= dp[x]

x = max(uninity).bit_length() - 1
print(x)
------------------------------------------------------------

[code_sha1]: 6d5b68567d459a132745e36fefd29e73eb007ee9

[code_bytes]: 801

[language]: Python

[status]: Wrong Answer

[date]: 1576336320

[user_id]: u102461423

[n_chars]: 775

[n_lines]: 42

======================================================================
샘플 #3
======================================================================

[submission_id]: s936829593

[problem_id]: p03824

[text]:
------------------------------------------------------------
import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

import numpy as np

N = int(readline())
m = map(int,read().split())
AB = zip(m,m)

graph = [[] for _ in range(N+1)]
for a,b in AB:
    graph[a].append(b)
    graph[b].append(a)

root = 1
parent = [0] * (N+1)
order = []
stack = [root]
while stack:
    x = stack.pop()
    order.append(x)
    for y in graph[x]:
        if y == parent[x]:
            continue
        parent[y] = x
        stack.append(y)

uninity = [0] * (N+1)
dp = [np.zeros(30,np.int64) for _ in range(N+1)]
answer = -1
for x in order[::-1]:
    p = parent[x]
    A = dp[x]
    twice = (A >= 2)
    if np.any(twice):
        k = np.where(twice)[0].max()
        A[:k] = 1
    lsb = np.where(A == 0)[0].min()
    if answer < lsb:
        answer += 1
    uninity[x] = lsb
    A[lsb] = 1
    A[:lsb] = 0
    A[A>0] = 1
    dp[p] += A

print(answer)
------------------------------------------------------------

[code_sha1]: a37e684fb277d8ed192f53272f06703663785a01

[code_bytes]: 930

[language]: Python

[status]: Time Limit Exceeded

[date]: 1576337390

[user_id]: u102461423

[n_chars]: 930

[n_lines]: 49

======================================================================
샘플 #4
======================================================================

[submission_id]: s677601693

[problem_id]: p03824

[text]:
------------------------------------------------------------
import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

import numpy as np

N = int(readline())
m = map(int,read().split())
AB = zip(m,m)

graph = [[] for _ in range(N+1)]
for a,b in AB:
    graph[a].append(b)
    graph[b].append(a)

root = 1
parent = [0] * (N+1)
order = []
stack = [root]
while stack:
    x = stack.pop()
    order.append(x)
    for y in graph[x]:
        if y == parent[x]:
            continue
        parent[y] = x
        stack.append(y)

full = (1 << 60) - 1
uninity = [0] * (N+1)
dp = [0] * (N+1)
twice = [0] * (N+1)
for x in order[::-1]:
    p = parent[x]
    n = twice[x].bit_length() - 1
    if n >= 0:
        dp[x] |= (1 << (n+1)) - 1
    can_use = full & (~dp[x])
    lsb = can_use & (-can_use)
    uninity[x] = lsb
    dp[x] |= lsb
    dp[x] &= full & ~(lsb - 1)
    
    twice[p] |= (dp[x] & dp[p])
    dp[p] |= dp[x]

x = max(uninity)
answer = x.bit_length() - 1
print(answer)
------------------------------------------------------------

[code_sha1]: 06560cee7a23045597c65abb4d5ac583e3b92e9d

[code_bytes]: 970

[language]: Python

[status]: Accepted

[date]: 1576337889

[user_id]: u102461423

[n_chars]: 970

[n_lines]: 50

======================================================================
샘플 #5
======================================================================

[submission_id]: s496979761

[problem_id]: p03824

[text]:
------------------------------------------------------------
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def calc(rt):
    e = edge[rt]
    f[rt] = 1
    g[rt] = 1
    g1 = 0
    g2 = 0
    for son in e:
        if(f[son] == 0):
            calc(son)
            res = f[son]
            if(res > f[rt]):
                f[rt] = res
            res = g[son]
            if res + 1 > g[rt]:
                g[rt] = res + 1
            if(res > g1):
                g2 = g1
                g1 = res
            elif (res > g2):
                g2 = res
    if g1 + g2 + 1 > f[rt]:
        f[rt] = g1 + g2 + 1
    if g[rt] > f[rt]:
        f[rt] = g[rt]

n = int(input())
edge = []
f = []
g = []
for i in range(0,n):
    edge.append(set())
    f.append(0)
    g.append(0)

for i in range(1,n):
    e = input().split(' ')
    y = int(e[0]) - 1
    x = int(e[1]) - 1
    edge[x].add(y)
    edge[y].add(x)

calc(0)

length = f[0]
ans = 0
l = 1
while l < length:
    ans = ans + 1
    l = l + l + 1
print(ans)

------------------------------------------------------------

[code_sha1]: 3ed36605c089968d25066c6c240fdc192c3f61a0

[code_bytes]: 946

[language]: Python

[status]: Wrong Answer

[date]: 1485991123

[user_id]: u934019430

[n_chars]: 946

[n_lines]: 54

======================================================================
샘플 #6
======================================================================

[submission_id]: s479647514

[problem_id]: p03794

[text]:
------------------------------------------------------------
def build_graph(inp):
    nodes = dict()
    names = dict()
    N = None

    for line in inp:
        # special handling for first line of input -- seed vertices
        if N is None:
            N = int(line.strip())
            for k in range(1, N + 1):
                nodes[k] = set()
                names[id(nodes[k])] = nodes[k]
            continue

        # create edges
        i, k = map(int, line.split())
        nodes[i].add(k)
        nodes[k].add(i)

    return nodes, names


def longest_trace_from(nodes, start, exclude=None):
    traces = [longest_trace_from(nodes, n, exclude=start) for n in nodes[start] if n is not exclude] + [()]
    return (start,) + max(traces, key=len)


def longest_path(nodes):
    """ Find a longest path in the graph:
        Start with a random node, and find a longest trace from there.
        Re-start from the end of that trace and find a lognest trace.
        This will be the longest path in a graph, if graph is a tree. """
    if not nodes:
        return ()
    random = next(iter(nodes))
    start = longest_trace_from(nodes, random)[-1]
    return longest_trace_from(nodes, start)


def shape(nodes, start, exclude=None):
    parts = [shape(nodes, n, exclude=start) for n in nodes[start] if n is not exclude]
    return tuple(sorted(parts))  # any stable order will do


def shape2(nodes, start, exclude=frozenset()):
    parts = [shape(nodes, n, exclude=exclude.union([start])) for n in nodes[start] if n not in exclude]
    return tuple(sorted(parts))  # any stable order will do


def subtree_limits(path):
    L = len(path)
    excl = [frozenset(path[:i][-1:] + path[i + 1:][:1]) for i in range(L)]
    high = [min(i, L - i - 1) for i in range(L)]
    lims = [tuple((H - i, i) for i in range(H // 2 + 1)) for H in high]
    return tuple(dict(start=path[i], exclude=excl[i], limits=lims[i]) for i in range(L))


def combinations(nodes):
    rv = 2
    cache = dict()
    path = longest_path(nodes)
    for d in subtree_limits(path):
        this = d["start"]
        sh = shape2(nodes, d["start"], exclude=d["exclude"])
        for l, r in d["limits"]:
            if not l or not r:
                break  # left == 0 means all right and vv.
        # NOT FINISHED


import pytest
import pprint


def test_sl():
    # pprint.pprint(subtree_limits(tuple(range(9))))  # manual check
    pass


@pytest.fixture
def sample_data1():
    data = """4
              1 2
              1 3
              1 4""".strip().splitlines()
    return build_graph(data)


@pytest.fixture
def nodes(sample_data1):
    nodes, name = sample_data1
    return nodes


def test_com(nodes):
    combinations(nodes)


def test_build(nodes):
    # print(nodes)  # visual inspection
    pass


def test_ltf(nodes):
    assert len(longest_trace_from(nodes, 1)) == 2  # e.g. (1, 2)
    assert len(longest_trace_from(nodes, 2)) == 3  # e.g. (2, 1, 3)


def test_lp(nodes):
    assert len(longest_path(nodes)) == 3  # e.g. (2, 1, 3)
------------------------------------------------------------

[code_sha1]: 6919fd6ffc6da79ee15abfd26b8bdaead0cc0af4

[code_bytes]: 2965

[language]: Python

[status]: Runtime Error

[date]: 1488081601

[user_id]: u880644800

[n_chars]: 2965

[n_lines]: 110

======================================================================
샘플 #7
======================================================================

[submission_id]: s404688480

[problem_id]: p03794

[text]:
------------------------------------------------------------
# doc: git.io/vy4co
def graph(inp):
    nodes = dict()
    N = None
    for line in inp.splitlines():
        if N is None:
            N = int(line.strip())
            for k in range(1, N + 1):
                nodes[k] = set()
            continue
        i, k = map(int, line.split())
        nodes[i].add(k)
        nodes[k].add(i)
    return nodes

def trace(nodes, start, exclude=None):
    return (start,) + max([trace(nodes, n, exclude=start) for n in nodes[start] if n != exclude], key=len, default=())

def tree(nodes, start, exclude=None):
    return tup([tree(nodes, n, exclude=start) for n in nodes[start] if n != exclude])

class tup(tuple):
    def __new__(cls, arg=()):
        rv = super().__new__(cls, arg)
        rv.height = (1 + min((t.height[0] for t in rv), default=-1),
                     1 + max((t.height[1] for t in rv), default=-1))
        rv.edges = len(rv) + sum(t.edges for t in rv)
        return rv

def combinations(nodes):
    path = trace(nodes, trace(nodes, next(iter(nodes)))[-1])
    D = len(path)
    C = D // 2
    root = path[D // 2]
    if D % 2:
        thetree = tree(nodes, root)
        return sum(enum(limits, thetree) for limits in zip(range(C + 1), reversed(range(C + 1))))
    else:
        left = path[D // 2 - 1]
        left_tree = tup([tree(nodes, left, exclude=root)])
        right_tree = tree(nodes, root, exclude=left)
        lg = [i // 2 for i in range(1, C * 2 + 2)]
        ll = list(zip(lg, reversed(lg)))
        rg = [i // 2 for i in range(C * 2 + 1)]
        rl = list(zip(rg, reversed(rg)))
        tot = 0
        for i in range(len(ll)):
            left_limits = ll[i]
            right_limits = rl[i]
            lrv = enum(left_limits, left_tree) - sum(enum(ne, left_tree) for ne in ll[i - 1: i] + ll[i + 1: i + 2])\
                if sum(left_limits) > C else enum(left_limits, left_tree)
            rrv = enum(right_limits, right_tree)
            tot += lrv * rrv
        return tot

def enum(limits, shape, _cache=dict()):
    limits = tuple(sorted(limits))
    r, b = limits
    low, high = shape.height

    if r >= high:
        return 2 ** shape.edges

    if 0 in limits:
        return 1

    key = hash((r, b, shape))
    if key not in _cache:
        tot = 1
        for subtree in shape:
            acc = 0
            for sublimit in ((r - 1, b), (r, b - 1)):
                acc += enum(sublimit, subtree)
            tot *= acc
        _cache[key] = tot
    return _cache[key]

import sys
sys.setrecursionlimit(99999)
g = graph(sys.stdin.read())
rv = combinations(g)
print(rv % (10 ** 9 + 7))
------------------------------------------------------------

[code_sha1]: 7923e539fdc7962b9db8210b12a1aeb530dc2141

[code_bytes]: 2587

[language]: Python

[status]: Accepted

[date]: 1489110858

[user_id]: u880644800

[n_chars]: 2587

[n_lines]: 82

======================================================================
샘플 #8
======================================================================

[submission_id]: s292744009

[problem_id]: p03794

[text]:
------------------------------------------------------------
print "j"
------------------------------------------------------------

[code_sha1]: 463ab6a53cdfe21079bd8d30ae881aa77389b2ce

[code_bytes]: 9

[language]: Python

[status]: Runtime Error

[date]: 1596489740

[user_id]: u111605722

[n_chars]: 9

[n_lines]: 1

======================================================================
샘플 #9
======================================================================

[submission_id]: s713490185

[problem_id]: p02945

[text]:
------------------------------------------------------------
a, b = map(int,input().split())
print(max(a + b, a - b, a * b))
------------------------------------------------------------

[code_sha1]: 084db9ca9d073f2e0be54ecb0f36f3b2972e2228

[code_bytes]: 63

[language]: Python

[status]: Accepted

[date]: 1585958584

[user_id]: u163874353

[n_chars]: 63

[n_lines]: 2

======================================================================
샘플 #10
======================================================================

[submission_id]: s721447333

[problem_id]: p02945

[text]:
------------------------------------------------------------
import sys
import heapq
import math
import fractions
import bisect
import itertools
from collections import Counter
from collections import deque
from operator import itemgetter
def input(): return sys.stdin.readline().strip()
def mp(): return map(int,input().split())
def lmp(): return list(map(int,input().split()))

a,b=mp()
print(max(a+b,a-b,a*b))
------------------------------------------------------------

[code_sha1]: 9acb4bcb14e61d10e9d7fdb20bc0eccdda916a63

[code_bytes]: 351

[language]: Python

[status]: Accepted

[date]: 1597704422

[user_id]: u024782094

[n_chars]: 351

[n_lines]: 15

======================================================================
✅ 완료!
======================================================================
